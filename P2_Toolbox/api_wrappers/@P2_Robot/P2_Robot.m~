% A Wrapper for the RaspBot/Neato Robot API Class
% We might be glad we made this later if we need one so we don't have to
% our other API functions/classes to include it later on.
% (N.B. Large methods of the class stored in @P2_Robot class folder)
classdef P2_Robot
    %% PROPERTIES
    properties (GetAccess=public, SetAccess=private)
        core;           % RaspBot Core Class (manages ROS communication, et al)
        on_time;        % Time (tic) that the debugger started
        
        %Odometry:
        trip_startTime; % Time Most Recent Trip Started (odometry)
        init_enc_l;     % Left Encoder Reading from Start of Trip
        init_enc_r;     % Left Encoder Reading from Start of Trip
    end % P2_Robot->properties(public,private)
    
    properties (GetAccess=public, SetAccess=public)
        %Motion:
        l2r_ratio = 1;  % Ratio of Natural Left-to-Right Wheel Running Speeds (Curvature Correction)
    end % P2_Robot->properties(public,public)
    
    methods
        %% Constructor
        % rb - RaspBot/Neato Robot Class which manages ROS Communication
        function obj = P2_Robot(rb)
            if nargin>0
                if isa(rb,'raspbot')
                    obj.core = rb;
                else
                    error('Debugger Robot must be a raspbot')
                end % r is raspbot?
            else
                error('Must give Debugger a Robot to track')
            end% nargin>0?
            
            obj.on_time = tic;
            obj.startTrip(); % Default odometry starts at instantiation.
        end % #P2_Robot Constructor
        
        %% Destructor
        function delete(obj)
            obj.core.delete(); %Destruct Core Robot
        end % #delete
        
        %% ODOMETRY
        % Basic position tracking (time and encoder deltas, etc.)
        
        % Sets/Saves a new Robot State from which Odometry is Collected (overwrites 
        % previous).
        % Returns vector containing new state variables.
        state = startTrip(obj)
        
        % Time Elapsed since Start of Trip
        function t = tripTime(obj)
            t = toc(obj.trip_startTime);
        end
        
        % Change in Left Encoder Distance since Start of Trip
        function d = leftTripDist(obj)
            d = obj.core.encoders.LatestMessage.Vector.X - obj.init_enc_l;
        end
        % Change in Right Encoder Distance since Start of Trip
        function d = rightTripDist(obj)
            d = obj.core.encoders.LatestMessage.Vector.Y - obj.init_enc_r;
        end % #rightTripDist
        % Change in Average Encoder Distance since Start of Trip
        function d = avgTripDist(obj)
            d = (obj.leftTripDist + obj.rightTripDist) / 2;
        end % #rightTripDist
        
        %% MOTION
        % Methods for going places
        
        %Run Robot with relative wheel velocities v_l, v_r, correcting for
        %curvature defined by L2R_Factor (Ratio of Left-to-Right Wheel Running
        %Speeds )
        function run_correct(obj, v_l, v_r)
            obj.sendVelocity(v_l/obj.l2r_ratio,v_r)
        end % #runStraight
        
        % Go to Specified One-Dimensional Position relative to current 
        % position with velocity curve starting at PEAK_SPEED and
        % decelerating to MIN_SPEED exponentially after half the distance
        % has been covered.
        % (N.B.: resets trip odometer)
        function go_to(obj, pos)
            global init_l init_r
            global PEAK_SPEED MIN_SPEED

            strt = obj.avgTripDist(); %starting position
            D_TS = pos - strt; %delta btwn starting and target position
            abs_dts = abs(D_TS);

            D_TC = pos - strt; %delta btwn Current and Target position
            abs_dtc = abs(D_TC);

            spd = PEAK_SPEED;
            while (spd ~= 0)
                ad = avg_dist(rob, init_l,init_r);

                D_CS = ad -strt; %delta btwn Start and Current Position
                abs_dcs = abs(D_CS);

                D_TC = pos - ad; %delta btwn Current and Target position
                abs_dtc = abs(D_TC);

                if(abs_dcs > abs_dts/2) %if past half-way
                    spd = (PEAK_SPEED-MIN_SPEED) * abs_dtc/(abs_dts/2) + MIN_SPEED;
                end% if |DCS|>|DTS|/2
                if(abs_dcs > abs_dts) %if done.
                    spd = 0;
                end % if |DCS|>|DTS|

                if(D_TS < 0) %Go Backwards
                    [avg_dist(rob, init_l,init_r) pos -spd]
                    runStraight(rob, -spd,-spd,L2R_FACTOR);
                else %Go Forward
                    [avg_dist(rob, init_l,init_r) pos spd]
                    runStraight(rob, spd,spd,L2R_FACTOR);
                end % D_TS<0

                pause(0.05)
                debug_EncoderPosition(rob);
            end %while(spd~=0)
    end % P2_Robot->methods
end % P2_Robot