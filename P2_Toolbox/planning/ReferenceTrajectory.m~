% Abstract SuperClass for All Trajectory Planning Curves, defining a
% standard set of external access methods and properties so that algorithms
% using one RT (ex TTC) can easily substitute it for another (ex. TCS).
% ... sadly (but obviously), this requires Heterogeneous Mixins and sealed 
% data access
classdef (Abstract) ReferenceTrajectory < Trajectory & matlab.mixin.Heterogeneous
    %% PROPERTIES
    properties(GetAccess=public, SetAccess=public)
        init_pose;          % Initial Pose of the Trajectory
        transformed = 0;    % Whether the Entire Trajectory has been Transformed
        
        is_null = 0;        % Red flag to not mess with null methods.
    end % ReferenceTrajectory <-properties(public,public)
    
    properties(GetAccess=public, SetAccess=private)
        numSamples = 0; % Number of Samples in the Trajectory
        distArray = [];
        timeArray = [];
        curvArray = [];
        vlArray = [];
        vrArray = [];
        VArray = [];
        wArray = [];
        
        method = 'spline';  % Interpolation Method
    end % ReferenceTrajectory <-properties(public,private)
    
    properties(Abstract)
        
    end % ReferenceTrajectory <-properties(Abstract)
    
    
    %% METHODS
    methods(Abstract)
        
        % Compute Everything Necessary to Create a Follow-able Path
        compute(obj);
        
        % Transforms Every Pose in the Data-Set to World Coordinates based
        % on the Object's "init_pose" property.
        offsetInitPose(obj);
        
    end % ReferenceTrajectory <-methods(Abstract)
    
    % Sealed Accessors
    methods(Sealed)
        %% Interpolate
        % General Interpolation that takes into account out of bounds
        % queries, where v_ob is the value used for over-bounds queries.
        function v = genInt(obj,xs,vs, x, v_ob, v_ub)
            if (x < xs(1))
                v = v_ub;
            elseif(x <= xs(end))
                v = interp1(ts,vs, x, obj.method);
            else
                v = v_ob;
            end % t?
        end
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% - CURVE (SPATIAL)
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
             
        function s  = getDistAtDist(obj,s)
            s = obj.getInt( ...
                    obj.distArray,obj.distArray, s, ...
                    obj.distArray(numSamples), 0.0
            if( s < obj.distArray(1))
                s = 0.0;
            else
                s  = interp1(obj.distArray,obj.distArray,s,'pchip','extrap');  
            end
        end % #getDistAtDist
        
        function K  = getCurvAtDist(obj,s)
            if( s < obj.distArray(1))
                K = 0.0;
            else
                K  = interp1(obj.distArray,obj.curvArray,s,'pchip','extrap');  
            end
            
            if (obj.transformed == 0)
                %then transform this badboy before we're finished
                p = obj.poseToWorld(p,obj.init_pose);
            end
        end % #getCurvAtDist
            
        function p  = getPoseAtDist(obj,s)
            x = interp1(obj.distArray,obj.poseArray(1,:),s,'pchip','extrap');
            y = interp1(obj.distArray,obj.poseArray(2,:),s,'pchip','extrap');
            th = interp1(obj.distArray,obj.poseArray(3,:),s,'pchip','extrap');
            p  = pose(x, y, th);  
        end % #getPoseAtDist
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% - SIGNAL (TRANSIENT)
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        function V  = getVAtTime(obj,t)
            if( t < obj.timeArray(1))
                V = 0.0;
            elseif(t > obj.getFinalTime())
                V = obj.VArray(obj.numSamples);
            else
                V  = interp1(obj.timeArray,obj.VArray,t,'pchip','extrap');  
            end
        end % #getVAtTime
            
        function w  = getwAtTime(obj,t)
            if(t < obj.timeArray(1))
                w = 0.0;
            elseif(t > obj.getFinalTime())
                w = obj.wArray(obj.numSamples);
            else
                w  = interp1(obj.timeArray,obj.wArray,t,'pchip','extrap');  
            end
        end % #getwAtTime
            
        function p  = getPoseAtTime(obj,t)
            if(t > obj.getFinalTime())
                p = obj.getFinalPose();
            else
                x = interp1(obj.timeArray,obj.poseArray(1,:),t,'pchip','extrap');
                y = interp1(obj.timeArray,obj.poseArray(2,:),t,'pchip','extrap');
                th = interp1(obj.timeArray,obj.poseArray(3,:),t,'pchip','extrap');
                p  = pose(x,y,th);
            end
            
            if (obj.transformed == 0)
                %then transform this badboy before we're finished
                p = obj.poseToWorld(p,obj.init_pose);
            end
        end % #getPoseAtTime
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% - TERMINAL (END STATE)
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        function p  = getFinalPose(obj)
            if ~obj.is_null
                if obj.numSamples > 0
                    p  = pose(obj.poseArray(:,obj.numSamples));
                else
                    try
                        p = obj.init_pose;
                    catch
                        p = pose(0,0,0); % Return 0s if Init-Pose Not Set
                    end
                end
            else
                p = pose(0,0,0);
            end
        end % #getFinalPose
        
        function time  = getTrajectoryDuration(obj)
            if ~obj.is_null
                if obj.numSamples > 0
                    time  = obj.timeArray(:,obj.numSamples);
                else
                    time = 0;
                end
            else
                time = 0;
            end
        end % #getTrajectoryDuration
        
        function dist  = getTrajectoryDistance(obj)
            if ~obj.is_null
                if obj.numSamples > 0
                    dist  = obj.distArray(:,obj.numSamples);
                else
                    dist = 0;
                end
            else
                dist = 0;
            end
        end % #getTrajectoryDistance
        
    end % ReferenceTrajectory <-methods(Sealed)
    
end % Class ReferenceTrajectory